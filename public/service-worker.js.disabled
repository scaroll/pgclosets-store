/**\n * Service Worker for PG Closets Performance Optimization\n * Implements caching strategies for improved Core Web Vitals\n */\n\nconst CACHE_NAME = 'pg-closets-v1'\nconst STATIC_CACHE = 'pg-closets-static-v1'\nconst DYNAMIC_CACHE = 'pg-closets-dynamic-v1'\nconst IMAGE_CACHE = 'pg-closets-images-v1'\n\n// Static assets to cache immediately\nconst STATIC_ASSETS = [\n  '/',\n  '/manifest.json',\n  '/offline.html'\n]\n\n// Cache strategies\nconst CACHE_STRATEGIES = {\n  // Cache first for static assets\n  CACHE_FIRST: 'cache-first',\n  // Network first for dynamic content\n  NETWORK_FIRST: 'network-first',\n  // Stale while revalidate for images\n  STALE_WHILE_REVALIDATE: 'stale-while-revalidate'\n}\n\n// Install event - cache static assets\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(STATIC_CACHE)\n      .then(cache => {\n        return cache.addAll(STATIC_ASSETS)\n      })\n      .then(() => {\n        self.skipWaiting()\n      })\n  )\n})\n\n// Activate event - clean up old caches\nself.addEventListener('activate', (event) => {\n  event.waitUntil(\n    caches.keys()\n      .then(cacheNames => {\n        return Promise.all(\n          cacheNames\n            .filter(name => name !== STATIC_CACHE && name !== DYNAMIC_CACHE && name !== IMAGE_CACHE)\n            .map(name => caches.delete(name))\n        )\n      })\n      .then(() => {\n        self.clients.claim()\n      })\n  )\n})\n\n// Fetch event - implement caching strategies\nself.addEventListener('fetch', (event) => {\n  const { request } = event\n  const url = new URL(request.url)\n\n  // Only handle GET requests\n  if (request.method !== 'GET') return\n\n  // Handle different types of requests\n  if (isStaticAsset(url)) {\n    event.respondWith(cacheFirst(request, STATIC_CACHE))\n  } else if (isImage(url)) {\n    event.respondWith(staleWhileRevalidate(request, IMAGE_CACHE))\n  } else if (isAPIRequest(url)) {\n    event.respondWith(networkFirst(request, DYNAMIC_CACHE))\n  } else {\n    event.respondWith(networkFirst(request, DYNAMIC_CACHE))\n  }\n})\n\n// Cache first strategy - for static assets\nasync function cacheFirst(request, cacheName) {\n  const cache = await caches.open(cacheName)\n  const cached = await cache.match(request)\n  \n  if (cached) {\n    return cached\n  }\n  \n  try {\n    const response = await fetch(request)\n    if (response.status === 200) {\n      cache.put(request, response.clone())\n    }\n    return response\n  } catch (error) {\n    // Return offline page for navigation requests\n    if (request.mode === 'navigate') {\n      return caches.match('/offline.html')\n    }\n    throw error\n  }\n}\n\n// Network first strategy - for dynamic content\nasync function networkFirst(request, cacheName) {\n  const cache = await caches.open(cacheName)\n  \n  try {\n    const response = await fetch(request)\n    if (response.status === 200) {\n      cache.put(request, response.clone())\n    }\n    return response\n  } catch (error) {\n    const cached = await cache.match(request)\n    if (cached) {\n      return cached\n    }\n    \n    // Return offline page for navigation requests\n    if (request.mode === 'navigate') {\n      return caches.match('/offline.html')\n    }\n    \n    throw error\n  }\n}\n\n// Stale while revalidate strategy - for images\nasync function staleWhileRevalidate(request, cacheName) {\n  const cache = await caches.open(cacheName)\n  const cached = await cache.match(request)\n  \n  // Start fetch in background\n  const fetchPromise = fetch(request)\n    .then(response => {\n      if (response.status === 200) {\n        cache.put(request, response.clone())\n      }\n      return response\n    })\n    .catch(() => null)\n  \n  // Return cached version immediately if available\n  if (cached) {\n    // Update cache in background\n    fetchPromise\n    return cached\n  }\n  \n  // Wait for network if no cache\n  return fetchPromise\n}\n\n// Helper functions\nfunction isStaticAsset(url) {\n  return url.pathname.match(/\\.(js|css|woff|woff2|eot|ttf|otf)$/)\n}\n\nfunction isImage(url) {\n  return url.pathname.match(/\\.(jpg|jpeg|png|gif|webp|avif|svg)$/) ||\n         url.hostname.includes('blob.vercel-storage.com') ||\n         url.hostname.includes('images.unsplash.com') ||\n         url.hostname.includes('cdn.renin.com')\n}\n\nfunction isAPIRequest(url) {\n  return url.pathname.startsWith('/api/')\n}\n\n// Background sync for failed requests\nself.addEventListener('sync', (event) => {\n  if (event.tag === 'background-sync') {\n    event.waitUntil(doBackgroundSync())\n  }\n})\n\nasync function doBackgroundSync() {\n  // Retry failed requests when connection is restored\n  const cache = await caches.open(DYNAMIC_CACHE)\n  // Implementation for retrying failed requests\n}\n\n// Push notifications (if needed in future)\nself.addEventListener('push', (event) => {\n  if (event.data) {\n    const data = event.data.json()\n    const options = {\n      body: data.body,\n      icon: '/icon-192x192.png',\n      badge: '/badge-72x72.png',\n      vibrate: [100, 50, 100],\n      data: {\n        dateOfArrival: Date.now(),\n        primaryKey: data.primaryKey\n      }\n    }\n    \n    event.waitUntil(\n      self.registration.showNotification(data.title, options)\n    )\n  }\n})\n\n// Notification click handler\nself.addEventListener('notificationclick', (event) => {\n  event.notification.close()\n  \n  event.waitUntil(\n    clients.openWindow('/')\n  )\n})