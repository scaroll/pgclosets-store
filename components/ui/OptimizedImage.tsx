/**
 * OptimizedImage Component - Apple-Level Image Performance
 *
 * Features:
 * - Automatic format selection (AVIF → WebP → JPEG)
 * - Responsive srcset generation
 * - Blur placeholder during load
 * - Lazy loading by default
 * - Priority loading for above-fold images
 * - Automatic size calculation
 *
 * Usage:
 * ```tsx
 * <OptimizedImage
 *   src="/images/hero.png"
 *   alt="Custom closet design"
 *   width={1920}
 *   height={1080}
 *   priority={false}
 * />
 * ```
 */

'use client'

import Image from 'next/image'
import { useState, useEffect } from 'react'
import { cn } from '@/lib/utils'

interface OptimizedImageProps {
  src: string
  alt: string
  width?: number
  height?: number
  priority?: boolean
  loading?: 'lazy' | 'eager'
  className?: string
  objectFit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down'
  quality?: number
  sizes?: string
  blurDataURL?: string
  onLoad?: () => void
  fill?: boolean
}

// Image manifest type (generated by optimization script)
interface ImageManifestEntry {
  original: string
  aspectRatio: string
  originalSize: number
  blurDataURL: string
  variants: {
    avif?: { [size: string]: { url: string; size: number; width: number } }
    webp?: { [size: string]: { url: string; size: number; width: number } }
    jpeg?: { [size: string]: { url: string; size: number; width: number } }
  }
}

type ImageManifest = Record<string, ImageManifestEntry>

// Cache for image manifest
let imageManifest: ImageManifest | null = null

/**
 * Load image manifest (generated by optimization script)
 */
async function loadImageManifest(): Promise<ImageManifest> {
  if (imageManifest) return imageManifest

  try {
    const response = await fetch('/manifest.json')
    if (response.ok) {
      imageManifest = await response.json()
      return imageManifest
    }
  } catch (error) {
    console.warn('[OptimizedImage] Failed to load image manifest:', error)
  }

  return {}
}

/**
 * Get optimized image sources from manifest
 */
function getOptimizedSources(
  src: string,
  manifest: ImageManifest
): ImageManifestEntry | null {
  // Normalize path
  const normalizedSrc = src.startsWith('/') ? src.slice(1) : src

  // Check manifest for optimized versions
  const entry = manifest[normalizedSrc] || manifest[`public/${normalizedSrc}`]

  return entry || null
}

/**
 * Generate responsive image srcset
 */
function generateSrcSet(
  variants: ImageManifestEntry['variants'],
  format: 'avif' | 'webp' | 'jpeg'
): string {
  const formatVariants = variants[format]
  if (!formatVariants) return ''

  return Object.entries(formatVariants)
    .map(([_size, variant]) => `${variant.url} ${variant.width}w`)
    .join(', ')
}

/**
 * Default sizes attribute for responsive images
 */
const DEFAULT_SIZES =
  '(max-width: 640px) 100vw, (max-width: 1024px) 50vw, (max-width: 1536px) 33vw, 25vw'

export function OptimizedImage({
  src,
  alt,
  width,
  height,
  priority = false,
  loading = 'lazy',
  className,
  objectFit = 'cover',
  quality = 85,
  sizes = DEFAULT_SIZES,
  blurDataURL,
  onLoad,
  fill = false,
}: OptimizedImageProps) {
  const [manifest, setManifest] = useState<ImageManifest>({})
  const [isLoaded, setIsLoaded] = useState(false)
  const [hasError, setHasError] = useState(false)

  // Load manifest on mount
  useEffect(() => {
    loadImageManifest().then(setManifest)
  }, [])

  // Get optimized sources
  const optimizedEntry = getOptimizedSources(src, manifest)

  // Use blur placeholder from manifest or provided
  const placeholder = blurDataURL || optimizedEntry?.blurDataURL

  // Handle image load
  const handleLoad = () => {
    setIsLoaded(true)
    onLoad?.()
  }

  // Handle image error - fallback to placeholder or original
  const handleError = () => {
    console.warn('[OptimizedImage] Failed to load optimized image, falling back:', src)
    setHasError(true)
  }

  // If optimized versions exist, use picture element for format selection
  if (optimizedEntry && !hasError) {
    const avifSrcSet = generateSrcSet(optimizedEntry.variants, 'avif')
    const webpSrcSet = generateSrcSet(optimizedEntry.variants, 'webp')
    const jpegSrcSet = generateSrcSet(optimizedEntry.variants, 'jpeg')

    return (
      <div className={cn('relative overflow-hidden', className)}>
        <picture>
          {/* AVIF - Best compression */}
          {avifSrcSet && <source type="image/avif" srcSet={avifSrcSet} sizes={sizes} />}

          {/* WebP - Good compression, wide support */}
          {webpSrcSet && <source type="image/webp" srcSet={webpSrcSet} sizes={sizes} />}

          {/* JPEG - Universal fallback */}
          {jpegSrcSet && <source type="image/jpeg" srcSet={jpegSrcSet} sizes={sizes} />}

          {/* Next.js Image component for the img element */}
          <Image
            src={src}
            alt={alt}
            width={width}
            height={height}
            priority={priority}
            loading={loading}
            quality={quality}
            sizes={sizes}
            placeholder={placeholder ? 'blur' : 'empty'}
            blurDataURL={placeholder}
            onLoad={handleLoad}
            onError={handleError}
            fill={fill}
            className={cn(
              'transition-opacity duration-300',
              isLoaded ? 'opacity-100' : 'opacity-0',
              objectFit === 'cover' && 'object-cover',
              objectFit === 'contain' && 'object-contain',
              objectFit === 'fill' && 'object-fill',
              objectFit === 'none' && 'object-none',
              objectFit === 'scale-down' && 'object-scale-down'
            )}
          />
        </picture>
      </div>
    )
  }

  // Fallback to standard Next.js Image
  return (
    <div className={cn('relative overflow-hidden', className)}>
      <Image
        src={src}
        alt={alt}
        width={width}
        height={height}
        priority={priority}
        loading={loading}
        quality={quality}
        sizes={sizes}
        placeholder={placeholder ? 'blur' : 'empty'}
        blurDataURL={placeholder}
        onLoad={handleLoad}
        fill={fill}
        className={cn(
          'transition-opacity duration-300',
          isLoaded ? 'opacity-100' : 'opacity-0',
          objectFit === 'cover' && 'object-cover',
          objectFit === 'contain' && 'object-contain',
          objectFit === 'fill' && 'object-fill',
          objectFit === 'none' && 'object-none',
          objectFit === 'scale-down' && 'object-scale-down'
        )}
      />
    </div>
  )
}

/**
 * Optimized Background Image Component
 * For hero sections and backgrounds
 */
export function OptimizedBackgroundImage({
  src,
  alt,
  priority = false,
  className,
  overlay = false,
  overlayOpacity = 0.3,
  children,
}: {
  src: string
  alt: string
  priority?: boolean
  className?: string
  overlay?: boolean
  overlayOpacity?: number
  children?: React.ReactNode
}) {
  return (
    <div className={cn('relative w-full h-full', className)}>
      <OptimizedImage
        src={src}
        alt={alt}
        fill
        priority={priority}
        objectFit="cover"
        quality={90}
      />
      {overlay && (
        <div
          className="absolute inset-0 bg-black pointer-events-none"
          style={{ opacity: overlayOpacity }}
        />
      )}
      {children && <div className="relative z-10">{children}</div>}
    </div>
  )
}

/**
 * Optimized Product Image Component
 * Optimized for product cards and galleries
 */
export function OptimizedProductImage({
  src,
  alt,
  priority = false,
  className,
  aspectRatio = '1/1',
}: {
  src: string
  alt: string
  priority?: boolean
  className?: string
  aspectRatio?: string
}) {
  return (
    <div className={cn('relative w-full overflow-hidden', className)} style={{ aspectRatio }}>
      <OptimizedImage
        src={src}
        alt={alt}
        fill
        priority={priority}
        objectFit="cover"
        quality={85}
        sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
      />
    </div>
  )
}

/**
 * Lazy Loaded Image Component
 * With intersection observer for below-fold images
 */
export function LazyOptimizedImage(props: OptimizedImageProps) {
  const [shouldLoad, setShouldLoad] = useState(false)
  const [ref, setRef] = useState<HTMLDivElement | null>(null)

  useEffect(() => {
    if (!ref || shouldLoad) return

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setShouldLoad(true)
          observer.disconnect()
        }
      },
      { rootMargin: '100px' } // Start loading 100px before visible
    )

    observer.observe(ref)

    return () => observer.disconnect()
  }, [ref, shouldLoad])

  if (!shouldLoad) {
    return (
      <div
        ref={setRef}
        className={cn('bg-gray-200 animate-pulse', props.className)}
        style={{
          aspectRatio: props.width && props.height ? `${props.width}/${props.height}` : '1/1',
        }}
      />
    )
  }

  return <OptimizedImage {...props} loading="lazy" />
}
